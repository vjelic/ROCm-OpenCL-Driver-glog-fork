{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "83125a33-07dd-302c-90c4-89d2aaba744c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(invalidBC)`, the vulnerability arises if `invalidBC` is not a null-terminated string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character at the end, or by manually adding a null character at the end of your string after it has been modified.\n\nAlso, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter specifying the maximum number of characters to read. This can prevent buffer overflows if the string is not null-terminated.\n\n## Source Code Fix Recommendation\n\nIf `invalidBC` is a character array, ensure it is null-terminated:\n\n```cpp\nchar invalidBC[] = \"some string\";\ninvalidBC[sizeof(invalidBC) - 1] = '\\0';\nsize_t length = strlen(invalidBC);\n```\n\nIf `invalidBC` is a pointer to a string, use `strnlen()` instead:\n\n```cpp\nchar* invalidBC = \"some string\";\nsize_t length = strnlen(invalidBC, MAX_LENGTH);\n```\n\nReplace `MAX_LENGTH` with the maximum expected length of the string.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "53e96b65-cb33-3852-be07-bbbe0485468e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory beyond the intended boundary, leading to a buffer overflow. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes a maximum length parameter and will not read beyond this limit.\n\n## Source Code Fix Recommendation\n\nIf you have a code snippet like this:\n\n```c++\nchar defined[100];\n// ... some code that populates 'defined' ...\nint length = strlen(defined);\n```\n\nYou can replace it with:\n\n```c++\nchar defined[100];\n// ... some code that populates 'defined' ...\ndefined[sizeof(defined) - 1] = '\\0'; // Ensure null-termination\nint length = strlen(defined);\n```\n\nOr use `strnlen()`:\n\n```c++\nchar defined[100];\n// ... some code that populates 'defined' ...\nint length = strnlen(defined, sizeof(defined));\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are needed.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "edbc1ccb-ee8f-37ad-99ab-30f6a77838d6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other undefined behaviors.\n\nThis vulnerability is particularly dangerous because it can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, use safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\nAlso, consider using higher-level string handling functions or classes that automatically handle string termination and length calculation, such as the `std::string` class in C++.\n\n## Source Code Fix Recommendation\n\nIf `invalidCL` is a string that may not be null-terminated, replace:\n\n```cpp\nstrlen(invalidCL);\n```\n\nwith:\n\n```cpp\nstrnlen(invalidCL, MAX_LENGTH);\n```\n\nwhere `MAX_LENGTH` is the maximum expected length of the string.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "0c392191-3f19-3d3d-b55f-87c493869bb5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other undefined behaviors.\n\nThis vulnerability is particularly dangerous because it can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, use safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\nAlso, consider using higher-level string handling functions or classes that automatically handle string termination and length calculation, such as the `std::string` class in C++.\n\n## Source Code Fix Recommendation\n\nIf `invalidCL` is a string that may not be null-terminated, replace:\n\n```cpp\nstrlen(invalidCL);\n```\n\nwith:\n\n```cpp\nstrnlen(invalidCL, MAX_LENGTH);\n```\n\nwhere `MAX_LENGTH` is the maximum expected length of the string.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "d34b3959-401a-37e2-bcb1-1560a581c6d5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(includeInvalid)` with `strnlen(includeInvalid, MAX_LENGTH)`, where `MAX_LENGTH` is the maximum expected length of the string.\n\n```cpp\n#include <string.h>\n\n#define MAX_LENGTH 100\n\n// ...\n\nsize_t length = strnlen(includeInvalid, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so you need to include the `<string.h>` or `<cstring>` header file.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "34e4f26a-8cf3-33a4-843d-323bd1a56ac4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory beyond the intended boundary, leading to a buffer overflow. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes a maximum length parameter and will not read beyond this limit.\n\n## Source Code Fix Recommendation\n\nIf you have a code snippet like this:\n\n```c++\nchar defined[100];\n// ... some code that populates 'defined' ...\nint length = strlen(defined);\n```\n\nYou can replace it with:\n\n```c++\nchar defined[100];\n// ... some code that populates 'defined' ...\ndefined[sizeof(defined) - 1] = '\\0'; // Ensure null-termination\nint length = strlen(defined);\n```\n\nOr use `strnlen()`:\n\n```c++\nchar defined[100];\n// ... some code that populates 'defined' ...\nint length = strnlen(defined, sizeof(defined));\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are needed.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "cf43cdf9-bd07-3d8e-8f68-3de6597121e3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory beyond the intended boundary, leading to a buffer overflow. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes a maximum length parameter and will not read beyond this limit.\n\n## Source Code Fix Recommendation\n\nIf you have a code snippet like this:\n\n```c++\nchar defined[100];\n// ... some code that populates 'defined' ...\nint length = strlen(defined);\n```\n\nYou can replace it with:\n\n```c++\nchar defined[100];\n// ... some code that populates 'defined' ...\ndefined[sizeof(defined) - 1] = '\\0'; // Ensure null-termination\nint length = strlen(defined);\n```\n\nOr use `strnlen()`:\n\n```c++\nchar defined[100];\n// ... some code that populates 'defined' ...\nint length = strnlen(defined, sizeof(defined));\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are needed.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "cc9e637a-4836-3273-99a9-38cabcdf27ac",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory beyond the intended boundary, leading to a buffer overflow. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes a maximum length parameter and will not read beyond this limit.\n\n## Source Code Fix Recommendation\n\nIf you have a code snippet like this:\n\n```c++\nchar defined[100];\n// ... some code that populates 'defined' ...\nint length = strlen(defined);\n```\n\nYou can replace it with:\n\n```c++\nchar defined[100];\n// ... some code that populates 'defined' ...\ndefined[sizeof(defined) - 1] = '\\0'; // Ensure null-termination\nint length = strlen(defined);\n```\n\nOr use `strnlen()`:\n\n```c++\nchar defined[100];\n// ... some code that populates 'defined' ...\nint length = strnlen(defined, sizeof(defined));\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are needed.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "ab31203c-57a5-3152-be81-53501a4005d2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will keep reading memory beyond the intended boundary, leading to a buffer overflow vulnerability. This can result in crashes, incorrect behavior, or potential execution of malicious code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that come from untrusted sources without validation. Consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nstrlen(include);\n```\n\nUse:\n\n```cpp\nstrnlen(include, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of the string. This ensures that `strnlen()` does not read beyond this length, even if it does not encounter a null character.\n\n## Library Dependencies\n\nThe `strlen()` and `strnlen()` functions are part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "d614d299-de7d-34a7-bcb7-fcf5cb71a1e0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will keep reading memory beyond the intended boundary, leading to a buffer overflow vulnerability. This can result in crashes, incorrect behavior, or potential execution of malicious code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that come from untrusted sources without validation. Consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nstrlen(include);\n```\n\nUse:\n\n```cpp\nstrnlen(include, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of the string. This ensures that `strnlen()` does not read beyond this length, even if it does not encounter a null character.\n\n## Library Dependencies\n\nThe `strlen()` and `strnlen()` functions are part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "4f42ff5a-5a70-3373-838f-2b18a3a93a9f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will keep reading memory beyond the intended boundary, leading to a buffer overflow vulnerability. This can result in crashes, incorrect behavior, or potential execution of malicious code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that come from untrusted sources without validation. Consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nstrlen(include);\n```\n\nUse:\n\n```cpp\nstrnlen(include, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of the string. This ensures that `strnlen()` does not read beyond this length, even if it does not encounter a null character.\n\n## Library Dependencies\n\nThe `strlen()` and `strnlen()` functions are part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "d53864c7-e21a-3aac-8cd9-3c2a93c7b28c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(includeInvalid)` with `strnlen(includeInvalid, MAX_LENGTH)`, where `MAX_LENGTH` is the maximum expected length of the string.\n\n```cpp\n#include <string.h>\n\n#define MAX_LENGTH 100\n\n// ...\n\nsize_t length = strnlen(includeInvalid, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so you need to include the `<string.h>` or `<cstring>` header file.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "af094504-c782-3085-8c8f-059ab1dd6e79",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will keep reading memory beyond the intended boundary, leading to a buffer overflow vulnerability. This can result in crashes, incorrect behavior, or potential execution of malicious code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that come from untrusted sources without validation. Consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nstrlen(include);\n```\n\nUse:\n\n```cpp\nstrnlen(include, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of the string. This ensures that `strnlen()` does not read beyond this length, even if it does not encounter a null character.\n\n## Library Dependencies\n\nThe `strlen()` and `strnlen()` functions are part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "1ef89170-c731-3e66-84bf-ea998cb17a55",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behaviors.\n\nIn the provided code snippet, the `strlen` function is used without checking if the string `s` is null-terminated. This can lead to the aforementioned issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that your strings are null-terminated before passing them to `strlen`. Additionally, consider using safer alternatives to `strlen` that take a maximum length parameter to prevent reading past the end of the string.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `strlen` is `strnlen`, which takes a maximum length parameter. Here's how you can modify the provided code snippet to use `strnlen`:\n\n```cpp\nsize_t max_length = 100; // Replace with the maximum expected length of s\ncompiler->NewBufferReference(DT_CL, s, strnlen(s, max_length));\n```\n\nIn this code, `strnlen` will stop reading `s` after `max_length` characters, even if it hasn't encountered a null character. This prevents the potential buffer overflow that could occur with `strlen`.\n\n## Library Dependencies\n\nThe provided code snippet appears to be part of a larger codebase, and it's not clear what libraries it depends on. However, the `strlen` function is part of the C standard library, which is included in C++ as well.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "8d51f3c4-82d8-3bfb-9e2f-830f7ad3db97",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `getenv` function is used, which can lead to security vulnerabilities if not used properly. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. If the environment variable is controlled by an attacker, it can lead to various security issues.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. If you need to use them, make sure to validate and sanitize all inputs. Do not trust user input or environment variables blindly. Always consider the possibility that they can be controlled by an attacker.\n\n## Source Code Fix Recommendation\n\nInstead of using `getenv`, consider using a safer alternative. If you still need to use `getenv`, make sure to validate the returned pointer. Here is an example of how you can do it:\n\n```cpp\nconst char* testDir = getenv(\"TEST_DIR\");\nif (testDir == nullptr) {\n    // Handle the error\n} else {\n    // Use testDir\n}\n```\n\n## Library Dependencies\n\nThe `getenv` function is part of the C standard library, so you need to include `cstdlib`.\n\n```cpp\n#include <cstdlib>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "43438f15-2385-3e7f-b477-f082f440b5df",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In this case, the `getenv` function is used, which can lead to security vulnerabilities as it accesses the environment variables of the system. If an attacker can modify these variables, they can manipulate the behavior of the program.\n\n## Mitigation Advice\n\nAvoid using functions that directly interact with the environment variables or system resources. If it's necessary to use such functions, ensure that the input is properly validated and sanitized to prevent any malicious manipulation. \n\n## Source Code Fix Recommendation\n\nInstead of using `getenv`, consider using a safer alternative that allows for error handling or input validation. For example, you could use a function that retrieves the environment variable and checks it against a whitelist of allowed values.\n\n```cpp\nconst char* getSafeEnv(const char* name) {\n    static const std::set<std::string> whitelist = {\"ALLOWED_ENV_VAR1\", \"ALLOWED_ENV_VAR2\"};\n    if (whitelist.find(name) != whitelist.end()) {\n        return getenv(name);\n    } else {\n        // Handle error or return a default value\n        return nullptr;\n    }\n}\n\n// Usage\nASSERT_NE(getSafeEnv(\"TEST_DIR\"), nullptr);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cassert` for the `ASSERT_NE` macro.\n- `cstdlib` for the `getenv` function.\n- `set` and `string` for the whitelist in the `getSafeEnv` function.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "74db67c2-dc44-39dc-89d3-ae570f6528b5",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In the provided code snippet, the `getenv` function is used, which can lead to security vulnerabilities if not used carefully. This function returns a pointer to the value in the environment, or NULL if there is no match. The returned string should not be modified by the program, but it can be overwritten by a subsequent call to `getenv`, `setenv`, or `unsetenv`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library or other trusted libraries. In the case of `getenv`, consider using a method that does not risk overwriting the returned string and ensures thread safety.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <string>\n\nstd::string llvmBin;\nconst char* rawLlvmBin = std::getenv(\"LLVM_BIN\");\nif(rawLlvmBin != nullptr) {\n    llvmBin = std::string(rawLlvmBin);\n}\n```\n\nIn this fixed code, we use `std::getenv` instead of `getenv`. The returned C-string is immediately converted to a `std::string` to prevent it from being overwritten by subsequent calls to `std::getenv`, `std::setenv`, or `std::unsetenv`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "52b7271a-7fec-319e-b9fe-0a45901653f3",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. The `getenv()` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or even code execution if an attacker can control the environment in which your program runs.\n\n## Mitigation Advice\n\nAvoid using environment variables for passing sensitive information because they can be accessed by any process in the user's session. If you must use environment variables, ensure that they are not used to control the flow of the application. \n\n## Source Code Fix Recommendation\n\nIf you must use an environment variable, consider using a safer alternative to `getenv()`, such as `secure_getenv()`. The `secure_getenv()` function behaves identically to `getenv()` but returns NULL if the process is being run with elevated privileges. This can help prevent privilege escalation attacks.\n\n```cpp\nlog_level = secure_getenv(\"AMD_OCL_LOG_LEVEL\");\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n* `cstdlib` - This library provides general purpose functions, including dynamic memory management, random number generation, communication with the environment, integer arithmetics, searching, sorting and converting.\n\n## References\n\n* [OWASP C++](https://owasp.org/www-community/vulnerabilities/Detected_Prohibited_C_Library_Functions)\n* [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "06901548-756a-3b37-8453-4621ab8bfa7f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In the provided code snippet, the `getenv` function is used, which can lead to security vulnerabilities. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or code execution vulnerabilities if the environment variable is controlled by an attacker.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In this case, consider using the `std::getenv` function from the `<cstdlib>` header, which is a safer alternative to the C `getenv` function.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n\n// ...\n\ndriver->CCPrintOptions = !!std::getenv(\"CC_PRINT_OPTIONS\");\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This header defines several general purpose functions, including dynamic memory management, random number generation, communication with the environment, integer arithmetics, searching, sorting and converting.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "8c644bda-20cd-35e5-9a9d-b8d506ec6ecf",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `getenv` function is used, which can lead to security vulnerabilities. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or other security issues if the environment variable contains sensitive information.\n\n## Mitigation Advice\n\nAvoid using the `getenv` function if possible. If you need to use environment variables, consider using a safer alternative that does not expose the entire environment block. Always validate and sanitize the input to the `getenv` function to prevent potential security issues.\n\n## Source Code Fix Recommendation\n\nInstead of using `getenv`, consider using a safer alternative. For example, you can use the `std::getenv` function in C++ which is safer than the C `getenv` function. Here is an example of how to use it:\n\n```cpp\n#include <cstdlib>\n\nstd::string sEnvVar = \"PATH\";\nconst char* env_p = std::getenv(sEnvVar.c_str());\nif (env_p) {\n    std::cout << \"Your PATH is: \" << env_p << '\\n';\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This header defines several general purpose functions, including dynamic memory management, random number generation, communication with the environment, integer arithmetics, searching, sorting and converting.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "fee09099-69d5-359d-8394-5834495eae24",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Found\" vulnerability in C++ refers to the use of certain C library functions that are considered unsafe due to their potential to create buffer overflows, format string vulnerabilities, or other security issues. In this case, the function `getenv()` is used, which can lead to security vulnerabilities as it returns a pointer to the value in the environment, and that value can be altered by an attacker.\n\n## Mitigation Advice\n\nAvoid using `getenv()` function directly. Instead, use safer alternatives that limit the potential for buffer overflows and other vulnerabilities. Always validate and sanitize input and output data. \n\n## Source Code Fix Recommendation\n\nInstead of using `getenv()`, consider using a safer alternative. For example, you can use a function that copies the environment variable into a buffer of a specified size, which can help prevent buffer overflows.\n\n```cpp\nchar* safe_getenv(const char* name) {\n    static char buffer[256];\n    if (getenv(name)) {\n        strncpy(buffer, getenv(name), sizeof(buffer) - 1);\n        buffer[sizeof(buffer) - 1] = '\\0';\n        return buffer;\n    } else {\n        return nullptr;\n    }\n}\n\nASSERT_NE(safe_getenv(\"LLVM_BIN\"), nullptr);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cassert`: for the `ASSERT_NE` macro.\n- `cstdlib`: for the `getenv` function.\n- `cstring`: for the `strncpy` function.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "cc362cad-7aa3-3a68-a326-8aacf2aa6f4c",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `fopen` function is used, which can lead to vulnerabilities if the input is not properly validated or sanitized. An attacker could potentially manipulate the input to open files they are not supposed to access or even execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions provided by the C++ Standard Library. In this case, instead of using `fopen`, you can use the `fstream` class from the C++ Standard Library which provides a higher level of abstraction and is generally safer to use.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `fstream`:\n\n```cpp\n#include <fstream>\n#include <string>\n\nstd::string name = \"filename\";\nstd::ifstream f(name.c_str());\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`: for file operations\n- `<string>`: for string operations\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e4ce6ee5-1de7-3101-8352-a4eb74d1f0ee",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflows, format string vulnerabilities, or other security problems. The `getenv` function is one such function. It returns a pointer to a string that is associated with the matched environment variable name. This can lead to security vulnerabilities if the returned string is modified, or if the program does not handle the possibility that `getenv` could return a null pointer if the specified environment variable does not exist.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `getenv` function. Instead, consider using safer alternatives that are less prone to security issues. Always validate and sanitize input, and handle the possibility of null pointers. \n\n## Source Code Fix Recommendation\n\nInstead of using `getenv`, you can use a safer alternative like `getenv_s`. Here is an example of how to use it:\n\n```cpp\n#include <stdlib.h>\n\nchar* value;\nsize_t requiredSize;\n\ngetenv_s(&requiredSize, NULL, 0, \"ENV_VAR\");\nif (requiredSize == 0)\n{\n    printf(\"The environment variable does not exist.\\n\");\n}\nelse\n{\n    value = (char*) malloc(requiredSize * sizeof(char));\n    if (value != NULL)\n    {\n        getenv_s(&requiredSize, value, requiredSize, \"ENV_VAR\");\n        printf(\"The value of the environment variable is: %s\\n\", value);\n    }\n    free(value);\n}\n```\n\nIn this code, `getenv_s` is used to safely get the value of an environment variable. It checks if the environment variable exists and handles the possibility of a null pointer.\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "edbc1ccb-ee8f-37ad-99ab-30f6a77838d6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/unittest/Tests.cpp"
                },
                "region": {
                  "startLine": 532,
                  "startColumn": 61,
                  "endLine": 532,
                  "endColumn": 78,
                  "charOffset": 17267,
                  "charLength": 17,
                  "snippet": {
                    "text": "strlen(invalidCL)",
                    "rendered": {
                      "text": "strlen(invalidCL)",
                      "markdown": "`strlen(invalidCL)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17267,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strlen_s(invalidCL, <size of invalidCL>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17267,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strnlen(invalidCL, <size of invalidCL>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "53e96b65-cb33-3852-be07-bbbe0485468e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/unittest/Tests.cpp"
                },
                "region": {
                  "startLine": 504,
                  "startColumn": 59,
                  "endLine": 504,
                  "endColumn": 74,
                  "charOffset": 16305,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(defined)",
                    "rendered": {
                      "text": "strlen(defined)",
                      "markdown": "`strlen(defined)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16305,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(defined, <size of defined>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16305,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(defined, <size of defined>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "83125a33-07dd-302c-90c4-89d2aaba744c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/unittest/Tests.cpp"
                },
                "region": {
                  "startLine": 545,
                  "startColumn": 66,
                  "endLine": 545,
                  "endColumn": 83,
                  "charOffset": 17731,
                  "charLength": 17,
                  "snippet": {
                    "text": "strlen(invalidBC)",
                    "rendered": {
                      "text": "strlen(invalidBC)",
                      "markdown": "`strlen(invalidBC)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17731,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strlen_s(invalidBC, <size of invalidBC>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17731,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strnlen(invalidBC, <size of invalidBC>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0c392191-3f19-3d3d-b55f-87c493869bb5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/unittest/Tests.cpp"
                },
                "region": {
                  "startLine": 519,
                  "startColumn": 61,
                  "endLine": 519,
                  "endColumn": 78,
                  "charOffset": 16813,
                  "charLength": 17,
                  "snippet": {
                    "text": "strlen(invalidCL)",
                    "rendered": {
                      "text": "strlen(invalidCL)",
                      "markdown": "`strlen(invalidCL)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16813,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strlen_s(invalidCL, <size of invalidCL>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16813,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strnlen(invalidCL, <size of invalidCL>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d34b3959-401a-37e2-bcb1-1560a581c6d5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/unittest/Tests.cpp"
                },
                "region": {
                  "startLine": 448,
                  "startColumn": 74,
                  "endLine": 448,
                  "endColumn": 96,
                  "charOffset": 14432,
                  "charLength": 22,
                  "snippet": {
                    "text": "strlen(includeInvalid)",
                    "rendered": {
                      "text": "strlen(includeInvalid)",
                      "markdown": "`strlen(includeInvalid)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14432,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strlen_s(includeInvalid, <size of includeInvalid>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14432,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strnlen(includeInvalid, <size of includeInvalid>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "34e4f26a-8cf3-33a4-843d-323bd1a56ac4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/unittest/Tests.cpp"
                },
                "region": {
                  "startLine": 475,
                  "startColumn": 59,
                  "endLine": 475,
                  "endColumn": 74,
                  "charOffset": 15347,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(defined)",
                    "rendered": {
                      "text": "strlen(defined)",
                      "markdown": "`strlen(defined)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15347,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(defined, <size of defined>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15347,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(defined, <size of defined>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "cf43cdf9-bd07-3d8e-8f68-3de6597121e3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/unittest/Tests.cpp"
                },
                "region": {
                  "startLine": 489,
                  "startColumn": 59,
                  "endLine": 489,
                  "endColumn": 74,
                  "charOffset": 15820,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(defined)",
                    "rendered": {
                      "text": "strlen(defined)",
                      "markdown": "`strlen(defined)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15820,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(defined, <size of defined>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15820,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(defined, <size of defined>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "cc9e637a-4836-3273-99a9-38cabcdf27ac",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/unittest/Tests.cpp"
                },
                "region": {
                  "startLine": 461,
                  "startColumn": 59,
                  "endLine": 461,
                  "endColumn": 74,
                  "charOffset": 14887,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(defined)",
                    "rendered": {
                      "text": "strlen(defined)",
                      "markdown": "`strlen(defined)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14887,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(defined, <size of defined>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14887,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(defined, <size of defined>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ab31203c-57a5-3152-be81-53501a4005d2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/unittest/Tests.cpp"
                },
                "region": {
                  "startLine": 447,
                  "startColumn": 66,
                  "endLine": 447,
                  "endColumn": 81,
                  "charOffset": 14327,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(include)",
                    "rendered": {
                      "text": "strlen(include)",
                      "markdown": "`strlen(include)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14327,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(include, <size of include>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14327,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(include, <size of include>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d614d299-de7d-34a7-bcb7-fcf5cb71a1e0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/unittest/Tests.cpp"
                },
                "region": {
                  "startLine": 417,
                  "startColumn": 66,
                  "endLine": 417,
                  "endColumn": 81,
                  "charOffset": 13184,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(include)",
                    "rendered": {
                      "text": "strlen(include)",
                      "markdown": "`strlen(include)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13184,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(include, <size of include>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13184,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(include, <size of include>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4f42ff5a-5a70-3373-838f-2b18a3a93a9f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/unittest/Tests.cpp"
                },
                "region": {
                  "startLine": 431,
                  "startColumn": 66,
                  "endLine": 431,
                  "endColumn": 81,
                  "charOffset": 13693,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(include)",
                    "rendered": {
                      "text": "strlen(include)",
                      "markdown": "`strlen(include)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13693,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(include, <size of include>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13693,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(include, <size of include>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d53864c7-e21a-3aac-8cd9-3c2a93c7b28c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/unittest/Tests.cpp"
                },
                "region": {
                  "startLine": 432,
                  "startColumn": 74,
                  "endLine": 432,
                  "endColumn": 96,
                  "charOffset": 13798,
                  "charLength": 22,
                  "snippet": {
                    "text": "strlen(includeInvalid)",
                    "rendered": {
                      "text": "strlen(includeInvalid)",
                      "markdown": "`strlen(includeInvalid)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13798,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strlen_s(includeInvalid, <size of includeInvalid>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13798,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strnlen(includeInvalid, <size of includeInvalid>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "af094504-c782-3085-8c8f-059ab1dd6e79",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/unittest/Tests.cpp"
                },
                "region": {
                  "startLine": 403,
                  "startColumn": 66,
                  "endLine": 403,
                  "endColumn": 81,
                  "charOffset": 12696,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(include)",
                    "rendered": {
                      "text": "strlen(include)",
                      "markdown": "`strlen(include)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12696,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(include, <size of include>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12696,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(include, <size of include>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1ef89170-c731-3e66-84bf-ea998cb17a55",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/unittest/Tests.cpp"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 50,
                  "endLine": 49,
                  "endColumn": 59,
                  "charOffset": 1321,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(s)",
                    "rendered": {
                      "text": "strlen(s)",
                      "markdown": "`strlen(s)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1321,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(s, <size of s>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/unittest/Tests.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1321,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(s, <size of s>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8d51f3c4-82d8-3bfb-9e2f-830f7ad3db97",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/unittest/Tests.cpp"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 14,
                  "endLine": 26,
                  "endColumn": 20,
                  "charOffset": 621,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "43438f15-2385-3e7f-b477-f082f440b5df",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/unittest/Tests.cpp"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 14,
                  "endLine": 25,
                  "endColumn": 20,
                  "charOffset": 577,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "74db67c2-dc44-39dc-89d3-ae570f6528b5",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/unittest/Tests.cpp"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 14,
                  "endLine": 24,
                  "endColumn": 20,
                  "charOffset": 543,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "52b7271a-7fec-319e-b9fe-0a45901653f3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/AmdCompiler.cpp"
                },
                "region": {
                  "startLine": 814,
                  "startColumn": 26,
                  "endLine": 814,
                  "endColumn": 32,
                  "charOffset": 28320,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "06901548-756a-3b37-8453-4621ab8bfa7f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/AmdCompiler.cpp"
                },
                "region": {
                  "startLine": 733,
                  "startColumn": 31,
                  "endLine": 733,
                  "endColumn": 37,
                  "charOffset": 25735,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "8c644bda-20cd-35e5-9a9d-b8d506ec6ecf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/AmdCompiler.cpp"
                },
                "region": {
                  "startLine": 805,
                  "startColumn": 20,
                  "endLine": 805,
                  "endColumn": 26,
                  "charOffset": 28126,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "fee09099-69d5-359d-8394-5834495eae24",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/unittest/Tests.cpp"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 14,
                  "endLine": 23,
                  "endColumn": 20,
                  "charOffset": 499,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "cc362cad-7aa3-3a68-a326-8aacf2aa6f4c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/AmdCompiler.cpp"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 12,
                  "endLine": 145,
                  "endColumn": 17,
                  "charOffset": 4013,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e4ce6ee5-1de7-3101-8352-a4eb74d1f0ee",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/AmdCompiler.cpp"
                },
                "region": {
                  "startLine": 234,
                  "startColumn": 14,
                  "endLine": 234,
                  "endColumn": 20,
                  "charOffset": 6082,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}